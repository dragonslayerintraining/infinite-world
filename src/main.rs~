use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

#[derive(Hash)]
struct Coordinates{
    x: i32,
    y: i32,
}

fn get_cell_seq(x: i32, y: i32,t: u32) -> u64 {
    let mut hasher = DefaultHasher::new();
    x.hash(&mut hasher);
    y.hash(&mut hasher);
    t.hash(&mut hasher);
    return hasher.finish();
}

#[derive(Clone)]
#[derive(Copy)]
#[derive(PartialEq)]
enum CellState{
    UNKNOWN,
    ACCEPT,
    REJECT,
}

fn get_cell_at(x: i32, y: i32, t: u32) -> CellState{
    if t == 0 {
        return CellState::UNKNOWN;
    }
    if get_cell_at(x, y, t-1) != CellState::UNKNOWN {
        return get_cell_at(x, y, t-1);
    }
    let pred: [[CellState; 3]; 3] = [[get_cell_at(x-1,y-1,t-1),get_cell_at(x  ,y-1,t-1),get_cell_at(x+1,y-1,t-1)],
    [get_cell_at(x-1,y  ,t-1),get_cell_at(x  ,y  ,t-1),get_cell_at(x+1,y  ,t-1)],
    [get_cell_at(x-1,y+1,t-1),get_cell_at(x  ,y+1,t-1),get_cell_at(x+1,y+1,t-1)]];

    if pred[1][1] != CellState::UNKNOWN {
        return pred[1][1];
    }
    for i in 0..2 {
        for j in 0..2 {
            if pred[i][j] == CellState::ACCEPT {
                return CellState::REJECT;
            }
        }
    }
    if get_cell_seq(x,y,t)%7 == 0 {
        return CellState::ACCEPT;
    }else{
        return CellState::UNKNOWN;
    }
}

fn cell_to_char(state: CellState) -> char {
    match state{
        CellState::UNKNOWN=>{'?'}
        CellState::ACCEPT=>{'#'}
        CellState::REJECT=>{' '}
    }
}

fn get_cell(x: i32, y: i32) -> char {
    let mut t = 0;
    while get_cell_at(x,y,t) == CellState::UNKNOWN {
        t += 1;
        if t == 5{
            break
        }
    }
    return cell_to_char(get_cell_at(x,y,t));
}

fn main() {
    println!("Hello, world!");
    for x in 0..5 {
        for y in 0..5 {
            print!("{}",get_cell(x,y));
        }
        println!();
    }
}
